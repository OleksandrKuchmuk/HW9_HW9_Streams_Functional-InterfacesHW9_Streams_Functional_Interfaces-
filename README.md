# HW9_Streams_Functional_Interfaces

Теорія:
1. Чи можна  статичні, дефолтні методи вписувати у Functional interface?   
Так 

2. Навіщо потрібна анотація @FunctionalInterface?
Вона показує що цей інтерфейс є функціональним
Якщо стоїть така анотація - інтерфейс може мати тільки один(і він мусить бути присутній) власний абстрактний метод, інакше буде помилка компіляції
крім того він може містити абстрактні методи, що визначені в класі Object і помилки компіляції не буде, але не зрозумів в чому тут сенс, скорше просто 
є така можливість і все, сенсу їх туди пхати неба, всеодно всі класи наслідуються від класу Object і можуть перевизначити цей метод в себе 

3. Чи можна 2 чи більше дефолтних методів визначити у Functional interface?
Так, обмеження діє тільки на один абстрактний метод

4. Чи можна 2 чи більше статичних методів визначити у Functional interface?
Так, обмеження діє тільки на один абстрактний метод

5. Чи можна 2 чи більше абстракнтих методів визначити у Functional interface?
Інтерфейс може мати тільки один(і він мусить бути присутній) власний абстрактний метод, інакше буде помилка компіляції

6. Які методи потрібно визначати/перевизначати у класі що реалізує інтерфейс? Статичні і дефолтні?
Необхідно перевизначити абстрактний метод, якщо клас не являється абстрактним, інакше буде помилка компіляції
Клас наслідник може перевизначати дефолтні методи інтерфейсу, який реалізує

7. Різниця між map() i flatMap() в Stream API
map() отримує в якості аргумента функцію(лямбду), для кожного об'єкта який поступає, виконує якусь задану і функцію
і повертає змінений об'єкт, потім перетворює ті всі вихідні об'єкти в фінальний стрім

flatMap() перетворює в стрім кожен об'єкт який є в початковому стрімі і повертає стрім, в якому об'єднані стріми
зі всіх об'єктів в початковому потоці 
